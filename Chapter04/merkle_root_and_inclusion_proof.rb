# ファイル名: merkle_root_and_inclusion_proof.rb

require 'digest'

# ============================================================
# 0. テストデータの生成
# ------------------------------------------------------------
# list = ["0", "1000", "2000", ..., "1999000"] の 2000 要素。
# Merkle tree の葉として扱う「元データ」の配列に相当する。
# 実際のブロックチェーンでは，ここに「取引(tx)一覧」などが入る。
# ============================================================
list = (0..1999).map { |n| (n * 1000).to_s }

# ============================================================
# 1. Merkle root の計算
# ------------------------------------------------------------
# 【理論】Merkle tree は
#
#   - 各データ d_i をハッシュした値 H(d_i) を「葉」とし
#   - 兄弟ノードのハッシュを連結して再度ハッシュする
#       H_parent = H( H_left || H_right )
#
# を繰り返していくことで，最上段に 1 つだけ残る「ルートハッシュ」
# (= Merkle root) を得る構造である。
#
# この Merkle root は，
#   - 全データ集合に対する「コミットメント（要約）」になり
#   - ハッシュ関数が衝突困難である限り，
#     root を固定したまま内部の一部だけ改ざんすることは非常に難しい
# という性質を持つ。
# ============================================================

# ------------------------------------------------------------
# データ配列 list から Merkle root を計算する高レベル関数
# ------------------------------------------------------------
def merkle_root(list)
  # 各データ d を SHA-256 でハッシュして「葉」の配列にする
  leaves = list.map { |d| Digest::SHA256.hexdigest(d) }
  # 葉の配列から再帰的に親ノードを計算
  mroot(leaves)
end

# ------------------------------------------------------------
# 葉ノード（ハッシュ値の配列）から Merkle root を再帰的に計算
#
# leaves: ["h_0", "h_1", ..., "h_{n-1}"]
#
# 奇数個のときは，最後の要素を「自分自身で複製」して
# ペアにする（Bitcoin にも見られる慣習的な処理）。
# ------------------------------------------------------------
def mroot(leaves)
  # ベースケース：葉が 1 個になったら，それがルート
  return leaves[0] if leaves.size == 1

  # 隣り合う 2 つずつ（[h0,h1], [h2,h3], ...）を親ノードにまとめる
  parent_level = leaves.each_slice(2).map do |d|
    if d.size == 2
      # 正常なペア (hL, hR)
      Digest::SHA256.hexdigest(d[0] + d[1])
    else
      # 余り 1 個のときは (h, h) としてペアを疑似的に作る
      Digest::SHA256.hexdigest(d[0] + d[0])
    end
  end

  # 親レベルに対して再帰を適用し，最終的な root を返す
  mroot(parent_level)
end

# 実際に Merkle root を計算
root = merkle_root(list)
# puts "Merkle root: #{root}"  # デバッグ用

# ============================================================
# 2. Merkle tree 本体（構造付き）の構成
# ------------------------------------------------------------
# ルート値だけでなく，「木構造」自体も保持しておくことで，
# あるデータ要素に対する「包含証明（membership / inclusion proof）」を
# 構成できる。
#
# ここでは，各ノードを
#   [ ノードのハッシュ値, [左部分木, 右部分木] ]
# という 2 要素の配列で表現する。
#
# 葉ノードは
#   [ 葉のハッシュ値, [] ]
# のように，子を空配列として表現する。
# ============================================================

# ------------------------------------------------------------
# データの配列を「[leaf_hash, []]」の配列に変換し，Merkle tree を構成
# ------------------------------------------------------------
def merkle_tree(list)
  # 葉： [ SHA256(d), [] ] という形のノードを並べた配列
  tree_leaves = list.map { |d| [Digest::SHA256.hexdigest(d), []] }
  mtree(tree_leaves)
end

# ------------------------------------------------------------
# ノード配列から上位レベルを構成し，最終的なルートノードを返す
#
# nodes:
#   [
#     [hash_L, [left_subtree, right_subtree]],
#     [hash_R, [left_subtree, right_subtree]],
#     ...
#   ]
# ベースケースでは，nodes.size == 1 となり，それがルートノード。
# ------------------------------------------------------------
def mtree(nodes)
  # ベースケース：1 個になったらそれがルート
  return nodes[0] if nodes.size == 1

  # 2 個ずつまとめて親ノードを作る
  upper = nodes.each_slice(2).map do |d|
    if d.size == 2
      left  = d[0]
      right = d[1]
      hash  = Digest::SHA256.hexdigest(left[0] + right[0])
      # 親ノードは [親ハッシュ, [左ノード, 右ノード]]
      [hash, [left, right]]
    else
      # 余り 1 個の場合は，自分自身を複製して左右の子にする
      left  = d[0]
      right = d[0]
      hash  = Digest::SHA256.hexdigest(left[0] + right[0])
      [hash, [left, right]]
    end
  end

  # 上位レベルのノード列に対して再帰
  mtree(upper)
end

# Merkle tree の構成
tree = merkle_tree(list)
# tree[0] が root のハッシュ値と一致するはず:
# tree[0] == root

# ============================================================
# 3. Merkle path（包含証明に使うパス）の構築
# ------------------------------------------------------------
# 【理論】ある葉のハッシュ h_leaf が Merkle root に含まれていることを
# 示すには，
#
#   - その葉 h_leaf
#   - root に至るまでの各レベルでの「兄弟ノードのハッシュ」
#
# を与えればよい。
#
# 検証者は
#   - h_leaf からスタートし
#   - 各レベルで「自分と兄弟のハッシュ」を連結してハッシュし
#   - 最後に得られた値が root と一致するかどうか
#
# を確認することで，「確かにこの葉はこの Merkle root に含まれている」
# ことを検証できる。
#
# ここでの merkle_path は，
#   - ノード構造 tree を辿り
#   - “対象のハッシュ値” を持つ葉に至るまでの兄弟ハッシュを集める
# ことで，そのパス（証明）を返す。
#
# 返り値の形式は少し特殊で，
#
#   - パスの各段で
#       ['*', sibling_hash]  : 対象は左側，右側の sibling_hash を付与
#       [sibling_hash, '*']  : 対象は右側，左側の sibling_hash を付与
#   - 上のペアがネストした配列として返ってくる
#
# という構造を取っている（教材コードのスタイルを踏襲）。
#
# 実運用で使うなら「(sibling_hash, :left_or_right) の配列」に
# 正規化しておくと検証コードを書きやすいが，
# ここでは元のロジックを尊重してコメントのみ追加している。
# ============================================================

def merkle_path(tree, hash)
  h  = tree[0]     # このノード自身のハッシュ値
  bL = tree[1][0]  # 左枝（左の子ノード）
  bR = tree[1][1]  # 右枝（右の子ノード）

  # --- ケース1: 対象ハッシュが左枝にあり，かつ左枝が葉ノードの場合 ---
  if bL[0] == hash
    if bL[1] == [] # 左枝が葉ノード（= 子を持たない）
      # ['*', bR[0]] は
      #   - '*'   : 自ノード側（ここでは左）は「これ以上ハッシュを辿らない」
      #   - bR[0] : 兄弟側（右）のハッシュ値
      # を表す。これが最下層の「兄弟ハッシュ」になる。
      return ['*', bR[0]]
    end

  # --- ケース2: 対象ハッシュが右枝にあり，かつ右枝が葉ノードの場合 ---
  elsif bR[0] == hash
    if bR[1] == [] # 右枝が葉ノード
      # [bL[0], '*'] は，
      #   - bL[0] : 左側の兄弟ハッシュ
      #   - '*'   : 自ノード側（右）は「これ以上辿らない」
      # を意味する。
      return [bL[0], '*']
    end

  # --- ケース3: このノード直下には対象がなく，さらに子を持つ場合 ---
  else
    # 葉ノードでないことを確認（左右どちらかにさらに木がある）
    if bL[1] != [] && bR[1] != []
      # 左枝を探索
      pL = merkle_path(bL, hash)
      # 右枝を探索
      pR = merkle_path(bR, hash)

      if pL != []
        # 左側にパスが見つかった場合，
        #   [pL, bR[0]]
        # という形で「右側の兄弟ハッシュ bR[0]」を上位のパスに付け足す。
        return [pL, bR[0]]
      elsif pR != []
        # 右側にパスが見つかった場合，
        #   [bL[0], pR]
        # という形で「左側の兄弟ハッシュ bL[0]」を付加する。
        return [bL[0], pR]
      else
        # どちらにも見つからない場合は「空のパス」として返す
        return []
      end
    else
      # 子を持たない（葉ノード）まで来てしまい，対象も見つからなかった
      return []
    end
  end
end

# ============================================================
# 4. 実験：特定データの Merkle path を求める
# ------------------------------------------------------------
# ここでは，
#   "10000" と "23000"
# を例に，その SHA-256 ハッシュを葉として扱い，
# Merkle tree 内での包含パスを求めている。
#
# 本来の包含証明検証は：
#   - この path と葉のハッシュを使って root を再計算し
#   - 計算結果と与えられた Merkle root を比較
# することで行う。
#
# （このファイルでは path を構成するところまでを示し，
#   path の表現形式そのものは元コードどおりのネスト配列にしている。）
# ============================================================

hash  = Digest::SHA256.hexdigest("10000")
hash2 = Digest::SHA256.hexdigest("23000")

path1 = merkle_path(tree, hash)
path2 = merkle_path(tree, hash2)

# デバッグ出力例（必要に応じてコメントアウトを外す）
# puts "Merkle root: #{root}"
# puts "hash(10000): #{hash}"
# puts "path1: #{path1.inspect}"
# puts "hash(23000): #{hash2}"
# puts "path2: #{path2.inspect}"

# ------------------------------------------------------------
# コメント：
# - merkle_root(list) と merkle_tree(list) は，
#   それぞれ「値のみの Merkle root」と「構造付きの Merkle tree」を
#   一貫したルール（奇数個の時は末尾複製）で構成している。
# - merkle_path(tree, hash) は，
#   指定した葉ハッシュが root に至るまでの間に遭遇する
#   「兄弟ノードのハッシュ列」をネスト配列で返す。
# - ハッシュ関数が衝突困難である限り，
#   包含証明を偽造するには
#     1. Merkle root を変える（= ブロックヘッダ全体を偽造）
#     2. ハッシュ衝突を見つける
#   などの困難な操作が必要になるため，
#   Merkle tree は「多くのデータを 1 つのハッシュにまとめて信頼させる」
#   強力な仕組みとしてブロックチェーンで広く使われている。
# ------------------------------------------------------------