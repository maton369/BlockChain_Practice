# ファイル名: weak_sha40_rho_collision.rb

require 'digest'

# ============================================================
# SHA-256 の先頭 40 ビット（= 10 文字の16進数）だけを返す
# 弱い暗号学的ハッシュ関数の実装
# ------------------------------------------------------------
# 本来の SHA-256 は 256 ビット（64桁の16進数）の出力を持つが，
# ここでは衝突探索を現実的な時間で行うために，
# 出力を先頭 40 ビットに切り詰めた「弱いハッシュ関数」を定義する。
#
# 出力空間の大きさは
#
#   16^10 = 2^(4*10) = 2^40
#
# 通りしかないため，完全な SHA-256（2^256 通り）と比べて
# 衝突探索が圧倒的に容易になる（約 2^20 ≒ 10^6 ステップ規模）。
# ============================================================
def sha40(x)
  # hexdigest は 64 桁16進文字列（256ビット）を返すので，
  # そのうち先頭 10 桁（40ビット）だけを切り出す。
  Digest::SHA256.hexdigest(x)[0..9]
end

# ============================================================
# フロイドの循環検出法（ρ法）による衝突ペア探索
# ------------------------------------------------------------
# h0 を初期値として，
#
#   x_{n+1} = H(x_n)
#
# という写像の列を考えると，有限集合上の写像なので
# いずれ「尾 + サイクル」構造（functional graph）になる。
#
# フロイドの ρ 法は，
#   - 亀（kame）: 1ステップずつ H を適用
#   - 兎（usagi）: 2ステップずつ H を適用
# の 2 つの列を同時に進めることで，
# 「サイクル内での合流点（ミーティングポイント）」を検出する。
#
# その後，
#   - 片方を初期値 h0 から
#   - もう片方を合流点から
# 同期的に 1 ステップずつ進めると，
# サイクルの入口（μ）で再度一致する。
#
# このとき，「入口に入る直前の値のペア」が
#
#   H(x) = H(y) かつ x != y
#
# を満たす衝突ペアになるので，その 2 つを返す。
#
# ランダム写像モデルのもとでは，
#   出力ビット数を n = 40 とすると状態数 N = 2^n，
#   ρ法の探索ステップ数は O(√N) ≒ 2^(n/2) = 2^20
# 程度が期待される。
# ============================================================
def rho(h0)
  # 亀と兎を同じ初期値からスタート
  kame  = h0
  usagi = h0

  # 1. 合流点の検出フェーズ（循環の存在確認）
  begin
    kame  = sha40(kame)         # 亀: 1ステップ進む
    usagi = sha40(sha40(usagi)) # 兎: 2ステップ進む
  end until kame == usagi       # 値が一致したら，同じ軌道上で合流したとみなす

  goryu = kame                  # 合流地点（サイクル内の点）を記録

  # 2. サイクル入口（μ）の探索フェーズ
  kame = h0                     # 亀を初期値 h0 にリセット
  begin
    # kame_p, goryu_p は「次に H をかける直前の値」を保持しておくための変数。
    # 最終的に H(kame_p) = H(goryu_p) となる衝突ペアとして返す。
    kame_p  = kame
    goryu_p = goryu

    kame  = sha40(kame)         # h0 からの列を1ステップ
    goryu = sha40(goryu)        # 合流点からの列も1ステップ
  end until kame == goryu       # 同じハッシュ値に到達したら，そこがサイクル入口 μ

  # kame_p, goryu_p は「入口 μ に入る直前の 2 点」なので，
  #   sha40(kame_p) == sha40(goryu_p)
  # かつ 典型的には kame_p != goryu_p
  # を満たす衝突ペアになっている。
  [kame_p, goryu_p]
end

# ============================================================
# 実験：初期値 "0000000000" から ρ 法で衝突ペアを探索
# ============================================================

if __FILE__ == $0
  pair = rho("0000000000")
  puts "衝突ペアの原像:"
  puts "  x = #{pair[0]}"
  puts "  y = #{pair[1]}"

  hx = sha40(pair[0])
  hy = sha40(pair[1])

  puts
  puts "それぞれのハッシュ値（先頭40ビット）:"
  puts "  H(x) = #{hx}"
  puts "  H(y) = #{hy}"

  if pair[0] != pair[1] && hx == hy
    puts
    puts "→ x ≠ y かつ H(x) = H(y) が成り立っているので，"
    puts "   sha40 に対する衝突ペアの発見に成功している。"
  else
    puts
    puts "※ 期待どおりの衝突条件になっていない可能性があります。"
  end
end