# ファイル名: hashcash_pow_experiment.rb

require 'digest'

# ------------------------------------------------------------
# hashcash(target)
# ------------------------------------------------------------
# ■目的
#   与えられた難易度ターゲット `target` に対して、
#   「ハッシュ値 < target」を満たすような原像 `pow`（Proof of Work）と、
#   そのときのハッシュ値（整数）を返す。
#
# ■理論背景（PoW と難易度）
#   SHA-256 の出力は 256ビットの値であり、
#   一様に [0, 2^256-1] の範囲に分布すると仮定できる（理想的な乱数関数とみなす）。
#
#   条件「hash < target」を満たす確率 p は、
#
#       p = target / 2^256
#
#   と考えられる。
#
#   したがって、成功するまでの試行回数 X は
#   「成功確率が p のベルヌーイ試行を繰り返したときの試行回数」
#   すなわち幾何分布に従い、その期待値は
#
#       E[X] = 1 / p = 2^256 / target
#
#   となる。
#
#   PoW の難易度を上げるとは、「target を小さくする」ことであり、
#   期待試行回数を増やして計算コストを上げることを意味する。
#   逆に target を大きくすると成功しやすくなり、難易度は下がる。
def hashcash(target)
  hash = 0
  pow  = ""
  size = 2**256  # SHA-256 の出力空間サイズ（理論上は 0〜2^256-1）

  # 条件 hash < target を満たすまで乱数 pow を取り直し続ける。
  # ここでは pow を単なる整数の文字列表現としているが、
  # 現実のブロックチェーンでは「ブロックヘッダ＋ノンス」などが原像になる。
  begin
    pow  = rand(size).to_s
    hash = Digest::SHA256.hexdigest(pow).to_i(16)
  end until hash < target

  # pow: 見つかった原像
  # hash: そのときのハッシュ値（整数）
  [pow, hash]
end

# ------------------------------------------------------------
# 難易度 2**240 での PoW 実行例
# ------------------------------------------------------------
# target = 2^240 のとき、
#
#   p = 2^240 / 2^256 = 1 / 2^16
#
# なので、成功までの期待試行回数は 2^16 ≒ 65,536 回となる。
# 1ハッシュあたりの処理時間を τ 秒とすると、
#
#   期待時間 E[T] ≒ 65,536 * τ
#
# となる。このコードでは、実際にそのオーダー感を観測している。
hashcash(2**240)


# ------------------------------------------------------------
# 実行時間の測定用関数
# ------------------------------------------------------------
# ■目的
#   与えられた target に対して hashcash を1回実行し、
#   その実行時間（秒）を返す。
#
# ■理論背景
#   hashcash(target) の実行時間は、
#   「成功するまでに必要な試行回数 X（幾何分布）」と
#   「1試行あたりの時間 τ」の積に対応する。
#
#       T = X * τ
#
#   X の期待値が 2^256 / target であることから、
#
#       E[T] = (2^256 / target) * τ
#
#   となり、target を 1ビット小さくする（例: 2^240 → 2^239）と、
#   期待試行回数と期待時間はほぼ「2倍」になる。
def hashcashTime(target)
  t0 = Time.now
  hashcash(target)
  Time.now - t0
end


# ------------------------------------------------------------
# 難易度を変えて実験する
# ------------------------------------------------------------
# 難易度 target を 2^240, 2^239, ..., 2^235 と変化させ、
# 実行時間がどの程度伸びるかを確認する。
#
#   target を 2^k から 2^(k-1) にすると、
#   成功確率 p は 2倍小さくなる（1/2^16 → 1/2^17 など）。
#   したがって期待試行回数と期待時間は 2倍になるはずである。
#
# 実測値はノイズを含むが、平均的には指数的な伸びが観察されることが期待される。

hashcashTime(2**240)
hashcashTime(2**239)
hashcashTime(2**238)
hashcashTime(2**237)
hashcashTime(2**236)
hashcashTime(2**235)


# ------------------------------------------------------------
# 100回実験して、平均時間と分散を推定する
# ------------------------------------------------------------
# N 回同じ target で PoW を実行し、
# 実行時間の平均と分散を数値的に求める。
#
# ■理論背景（幾何分布の期待値と分散）
#   成功確率 p の幾何分布 X に対して、
#
#       E[X]   = 1 / p
#       Var[X] = (1 - p) / p^2
#
#   となる。
#   実行時間 T = X * τ とみなすと、
#
#       E[T]   = τ / p
#       Var[T] = τ^2 * (1 - p) / p^2
#
#   となり、p が小さい（難易度が高い）ほど分散も大きくなる。
#
#   ここでは、その性質の一端を「経験的に」確認している。
N      = 100
TARGET = 2**240

data = (1..N).map { |_| hashcashTime(TARGET) }

# 平均時間（サンプル平均）
average = data.sum / N.to_f
average

# 分散（サンプル分散に近いが、ここでは母分散的に 1/N で割っている）
variance = data.map { |x| (x - average)**2 }.sum / N.to_f
variance


# ------------------------------------------------------------
# 難易度ターゲットの再調整
# ------------------------------------------------------------
# ■意図
#   上で求めた平均時間 `average` を用いて、
#
#       target = TARGET * average
#
#   という新しいターゲットを設定している。
#
# ■理論的解釈
#   もとの target = TARGET に対する平均実行時間を E[TARGET] ≒ average とする。
#
#   出力空間サイズを S = 2^256 と書くと、
#
#       E[TARGET] = (S / TARGET) * τ
#
#   ここで新しい target' を
#
#       target' = TARGET * E[TARGET]
#
#   とすると、
#
#       E[target'] = (S / target') * τ
#                  = (S / (TARGET * E[TARGET])) * τ
#                  = (S / TARGET) * τ * (1 / E[TARGET])
#                  = E[TARGET] * (1 / E[TARGET])
#                  = 1
#
#   という関係が期待される（近似的に）。
#
#   つまり、
#   「TARGET で測った平均実行時間 average を使ってターゲットを調整すると、
#    新しいターゲットでの期待実行時間が ≒ 1秒（もしくは 1単位時間）になる」
#   というキャリブレーションになっている。
#
#   実測ではノイズや有限サンプルの影響により完全に 1 にはならないが、
#   おおよそ「1 に近い値」になることが期待される。
target = TARGET * average

# 新しいターゲット target で再度 N 回計測し、平均実行時間を求める。
data2 = (1..N).map { |_| hashcashTime(target) }
average2 = data2.sum / N.to_f

# average2 は理論上は ≒ 1 に近づくことが期待される。
# これにより、「PoW の難易度ターゲットを時間基準で調整する」という
# ブロックチェーンの Difficulty Adjustment の考え方の一端を、
# 小さな実験で体感することができる。