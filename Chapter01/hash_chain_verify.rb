# ファイル名: hash_chain_verify.rb

require 'digest'

# ------------------------------------------------------------
# ハッシュチェーン検証関数
# ------------------------------------------------------------
# ■役割
# - hashchain : ["data1:prev_hash0", "data2:prev_hash1", ...] という形式のブロック列
# - prev_hash : チェーン開始時点の「直前ハッシュ」（IV に相当）
# - lasthash  : チェーン末尾のブロックに対する SHA-256 ハッシュ（コミットメント）
#
# この関数は、
#   1. 各ブロックが「直前ブロックのハッシュ値」を正しく参照しているか
#   2. 最後に計算された prev_hash が、与えられた lasthash と一致しているか
# をチェックすることで、ハッシュチェーン全体が改ざんされていないことを検証する。
#
# ■理論的な意味
# - ハッシュチェーンは、各ブロックが「一つ前のハッシュ」を含むことで、
#   全履歴を鎖状に結びつける仕組みになっている。
# - もし途中のブロックのデータが改ざんされると、
#   そのブロックから先のハッシュ値がすべて変化してしまうため、
#   この検証処理のどこかで不整合として検出される。
# - さらに、最後の lasthash との一致を確認することで、
#   「検証対象のチェーンが、期待されるコミットメント（lasthash）と整合しているか」
#   を確認している。
#
# つまり、この verifyhashchain は
#   「ハッシュチェーン全体が、期待される履歴と整合しているか」
# を検証する最小のバリデーションロジックになっている。
def verifyhashchain(hashchain, prev_hash, lasthash)
  # map のブロック内で外側の prev_hash を更新していくことで、
  # 先頭から順番にチェーンをたどりながら検証している。
  #
  # 各 block は "data:prev_hash_of_previous_block" という形式を仮定する。
  # そのうち ":" の右側（インデックス 1）が「直前ブロックのハッシュ値」である。
  chain_ok = hashchain.map do |block|
    # ブロックから「直前ブロックのハッシュ値」を取り出す
    # 例: "0002:5114..." → ["0002", "5114..."] の右側を取得
    hash = block.split(':')[1]

    if hash == prev_hash
      # 直前ブロックのハッシュ値が期待通りであれば、
      # 現在の block 全体に SHA-256 を適用して
      # 「次のステップに渡す prev_hash（= 現在ブロックのハッシュ）」を更新する。
      #
      # ここでの SHA-256(block) は
      #   hash_k = SHA-256("data_k:hash_{k-1}")
      # という再帰的定義になっており、
      # この連鎖構造が「チェーン全体へのコミットメント」を生成している。
      prev_hash = Digest::SHA256.hexdigest(block)
      true   # このブロックは整合している
    else
      # 期待される直前ハッシュと一致しない場合、
      # この地点でチェーンが改ざんされている（あるいは壊れている）と判断できる。
      false
    end
  end.all?  # すべてのブロックの検証が true であるかを確認

  # さらに「最後に計算された prev_hash」が、与えられた lasthash と一致しているかも確認する。
  #
  # 理論的には:
  # - lasthash は「最後のブロックに SHA-256 を適用した値」であり、
  # - それは同時に「これまでの全ブロック列に対するコミットメント（要約）」でもある。
  #
  # そのため、
  #   1) 各ブロックが正しく鎖でつながっていること（chain_ok）
  #   2) 再計算した最終ハッシュ prev_hash が lasthash と一致すること
  # が両方とも成り立てば、チェーン全体が期待される履歴と一致するとみなせる。
  chain_ok && (prev_hash == lasthash)
end

# ------------------------------------------------------------
# 使用例（コンテキスト）
# ------------------------------------------------------------
# 事前に以下のようなチェーンが構築されているとする：
#
#   IV        = "0000"
#   data_list = ["0001", "0002", "0003", "0004"]
#   blockchain = hashchain(data_list, IV)
#   lasthash   = Digest::SHA256.hexdigest(blockchain[-1])
#
# このとき、チェーンが改ざんされていなければ次の呼び出しは true を返す。
#
# verifyhashchain(blockchain, IV, lasthash)
# => true
#
# もし blockchain の途中の要素（例: "0003:..."）を勝手に書き換えると、
# - hash == prev_hash の判定が途中で false になり、
# - あるいは最後に計算された prev_hash が lasthash と一致しなくなり、
# 結果として verifyhashchain は false を返す。
#
# これはブロックチェーンにおける「チェーンの正当性検証」の縮図であり、
# 実際のブロックチェーンではここに加えて、
# - 各ブロック内のトランザクション検証
# - PoW / PoS などのコンセンサス条件の検証
# などが組み合わさって、より強固な安全性が実現されている。